"""Dynamic MCP tool creation integration."""

import logging
import os
import tempfile
from pathlib import Path
from typing import Dict, Any, Optional

from .base import MCPServer
from .registry import MCPRegistry

logger = logging.getLogger(__name__)


class MCPDynamicCreator:
    """Integrates MCPCreationComponent with FunctionCallAgent for dynamic tool creation."""
    
    def __init__(self, workspace_root: Path, registry: MCPRegistry):
        """Initialize dynamic MCP creator.
        
        Args:
            workspace_root: Root directory for workspace
            registry: MCP registry for managing servers
        """
        self.workspace_root = workspace_root
        self.registry = registry
        self.mcp_workspace = workspace_root / "mcp_tools"
        self.mcp_workspace.mkdir(exist_ok=True)
        
    async def create_tool_from_description(
        self, 
        task_description: str,
        llm_client: Any,
        max_retries: int = 2
    ) -> Optional[str]:
        """Create a new MCP tool from a task description.
        
        Args:
            task_description: Description of what the tool should do
            llm_client: LLM client for code generation
            max_retries: Maximum number of retry attempts
            
        Returns:
            Name of the created MCP server, or None if creation failed
        """
        try:
            # Import MCPCreationComponent
            from mcp_automation import MCPCreationComponent
            
            # Initialize MCP creator with workspace
            mcp_creator = MCPCreationComponent(
                llm_client=llm_client,
                working_dir=str(self.mcp_workspace)
            )
            
            # Create the MCP tool
            logger.info(f"Creating dynamic MCP tool for: {task_description}")
            created_mcp = mcp_creator.create_mcp(task_description, max_retries)
            
            if created_mcp:
                # Create MCP server configuration
                server_name = f"dynamic_{created_mcp.unique_id}"
                server_config = await self._create_server_config(created_mcp, server_name)
                
                # Register the new server
                if await self.registry.add_server_runtime(server_config):
                    logger.info(f"Successfully created and registered dynamic MCP tool: {server_name}")
                    return server_name
                else:
                    logger.error(f"Failed to register dynamic MCP server: {server_name}")
                    return None
            else:
                logger.error("Failed to create MCP tool")
                return None
                
        except ImportError:
            logger.error("MCPCreationComponent not available. Install required dependencies.")
            return None
        except Exception as e:
            logger.error(f"Error creating dynamic MCP tool: {str(e)}")
            return None
    
    async def _create_server_config(self, mcp_info: Any, server_name: str) -> MCPServer:
        """Create MCP server configuration from created tool.
        
        Args:
            mcp_info: MCP information from MCPCreationComponent
            server_name: Name for the server
            
        Returns:
            MCP server configuration
        """
        # Create a Python script that acts as an MCP server
        script_path = self.mcp_workspace / f"{server_name}.py"
        
        # Generate MCP server wrapper script
        server_script = self._generate_mcp_server_script(mcp_info)
        
        with open(script_path, 'w') as f:
            f.write(server_script)
        
        # Make script executable
        script_path.chmod(0o755)
        
        return MCPServer(
            name=server_name,
            command="python",
            args=[str(script_path)],
            description=f"Dynamic MCP tool: {mcp_info.description}",
            transport="stdio"
        )
    
    def _generate_mcp_server_script(self, mcp_info: Any) -> str:
        """Generate an MCP server script wrapper.
        
        Args:
            mcp_info: MCP information object
            
        Returns:
            Python script content for MCP server
        """
        return f'''#!/usr/bin/env python3
"""
Dynamic MCP Server: {mcp_info.name}
Generated by ii-agent MCP integration

Description: {mcp_info.description}
"""

import asyncio
import json
import sys
import subprocess
import tempfile
import os
from typing import Any, Dict, List

class DynamicMCPServer:
    """MCP Server wrapper for dynamically created tool."""
    
    def __init__(self):
        self.tool_name = "{mcp_info.name.lower().replace(' ', '_')}"
        self.tool_description = "{mcp_info.description}"
        self.script_code = """{mcp_info.script_code}"""
        self.setup_commands = {mcp_info.setup_commands}
        
    async def handle_initialize(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle initialize request."""
        return {{
            "protocolVersion": "2024-11-05",
            "capabilities": {{
                "tools": {{}}
            }},
            "serverInfo": {{
                "name": "{mcp_info.name}",
                "version": "1.0.0"
            }}
        }}
    
    async def handle_tools_list(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle tools/list request."""
        return {{
            "tools": [{{
                "name": self.tool_name,
                "description": self.tool_description,
                "inputSchema": {{
                    "type": "object",
                    "properties": {{
                        "input": {{
                            "type": "string",
                            "description": "Input for the tool"
                        }}
                    }},
                    "required": ["input"]
                }}
            }}]
        }}
    
    async def handle_tools_call(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle tools/call request."""
        tool_name = params.get("name")
        arguments = params.get("arguments", {{}})
        
        if tool_name != self.tool_name:
            return {{
                "content": [{{
                    "type": "text",
                    "text": f"Unknown tool: {{tool_name}}"
                }}],
                "isError": True
            }}
        
        try:
            # Create temporary script file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                f.write(self.script_code)
                script_path = f.name
            
            # Execute the script
            input_arg = arguments.get("input", "")
            result = subprocess.run(
                ["python", script_path, input_arg],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Clean up
            os.unlink(script_path)
            
            if result.returncode == 0:
                return {{
                    "content": [{{
                        "type": "text", 
                        "text": result.stdout
                    }}]
                }}
            else:
                return {{
                    "content": [{{
                        "type": "text",
                        "text": f"Error: {{result.stderr}}"
                    }}],
                    "isError": True
                }}
                
        except Exception as e:
            return {{
                "content": [{{
                    "type": "text",
                    "text": f"Execution error: {{str(e)}}"
                }}],
                "isError": True
            }}

async def main():
    """Main MCP server loop."""
    server = DynamicMCPServer()
    
    # JSON-RPC message loop
    while True:
        try:
            line = input()
            if not line:
                break
                
            request = json.loads(line)
            method = request.get("method")
            params = request.get("params", {{}})
            request_id = request.get("id")
            
            result = None
            error = None
            
            try:
                if method == "initialize":
                    result = await server.handle_initialize(params)
                elif method == "tools/list":
                    result = await server.handle_tools_list(params)
                elif method == "tools/call":
                    result = await server.handle_tools_call(params)
                elif method == "notifications/initialized":
                    # Notification, no response needed
                    continue
                else:
                    error = {{"code": -32601, "message": f"Method not found: {{method}}"}}
            except Exception as e:
                error = {{"code": -32603, "message": f"Internal error: {{str(e)}}"}}
            
            # Send response
            if request_id is not None:
                response = {{"jsonrpc": "2.0", "id": request_id}}
                if error:
                    response["error"] = error
                else:
                    response["result"] = result
                    
                print(json.dumps(response))
                sys.stdout.flush()
                
        except EOFError:
            break
        except Exception as e:
            # Log error and continue
            print(f"Error in main loop: {{str(e)}}", file=sys.stderr)

if __name__ == "__main__":
    asyncio.run(main())
'''

    async def list_dynamic_tools(self) -> List[str]:
        """List all dynamically created MCP tools.
        
        Returns:
            List of dynamic tool server names
        """
        server_status = await self.registry.get_server_status()
        dynamic_servers = [
            name for name in server_status.get("servers", {}).keys() 
            if name.startswith("dynamic_")
        ]
        return dynamic_servers
    
    async def remove_dynamic_tool(self, server_name: str) -> bool:
        """Remove a dynamically created MCP tool.
        
        Args:
            server_name: Name of the server to remove
            
        Returns:
            True if removed successfully
        """
        try:
            if not server_name.startswith("dynamic_"):
                logger.error(f"Not a dynamic tool: {server_name}")
                return False
            
            # Remove from registry
            await self.registry.remove_server_runtime(server_name)
            
            # Remove script file
            script_path = self.mcp_workspace / f"{server_name}.py"
            if script_path.exists():
                script_path.unlink()
            
            logger.info(f"Removed dynamic MCP tool: {server_name}")
            return True
            
        except Exception as e:
            logger.error(f"Error removing dynamic tool {server_name}: {str(e)}")
            return False